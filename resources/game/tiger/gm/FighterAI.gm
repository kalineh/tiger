
global MakeFighterAI = function(owner, name)
{
    local AI = table();

    AI.owner = owner;
    AI.name = name;
    AI.ai_thread = -1;
    AI.action_thread = -1;
    AI.delay = 0;

    AI.NotifyOwnerRelease = function()
    {
        threadKill(.ai_thread);
        threadKill(.update_thread);
        return false;
    };

    AI.NotifyOwnerTakeDamage = function(damage)
    {
        .delay = 0.5f;
        threadKill(.ai_thread);
        return true;
    };

    AI.Update = function()
    {
        while (true)
        {
            g_dump.ai = this;

            // TODO: player search
            //local target = .owner.world.FindNearestPlayer().pos;
            //local offset = target + v3(1.0f, 0.1f) * randfloat(-12.0f, 12.0f);
            //.MoveTo(.owner.pos + offset);

            if (.owner.stun > 0)
            {
                sleep(0.25f);
                continue;
            }

            if (.delay > 0.0f)
            {
                sleep(.delay);
                .delay = 0.0f;
                continue;
            }

            // TODO: use state instead of animation?
            if (.owner.anim.currAnimName == "knockdown" ||
                .owner.anim.currAnimName == "prone")
            {
                sleep(0.25f);
                continue;
            }

            // TODO: this kind of hides bugs
            if (threadIsAlive(.owner.action_thread))
            {
                sleep(0.25f);
                continue;
            }

            .ai_thread = this:thread(function()
            {
                local player = .owner.world.FindNearestPlayer();

                .MoveToEntity(player);
                .TryAttack(player);
            });

            while (threadIsAlive(.ai_thread))
            {
                yield();
            }

            sleep(randfloat(0.5f, 1.0f));
        }
    };

    AI.MoveToEntity = function(entity)
    {
        local limit = 60 * 6;

        while (true)
        {
            local target = entity.pos;
            local ofs = target - .owner.pos;
            local len = safe_length(ofs);
            local dir = safe_normalize(ofs);
            local speed = 0.1f + len * 0.005f;

            .owner.move_input = v2(dir * speed);

            if (abs(ofs.x) < 64.0f && abs(ofs.y) < 8.0f)
            {
                break;
            }

            if (randint(0, 1000) <= 2)
            {
                break;
            }

            .WaitActionThread();

            yield();
        }
    };

    AI.MoveToPosition = function(position)
    {
        local limit = 60 * 6;

        while (true)
        {
            local ofs = position - .owner.pos;
            local len = safe_length(ofs);
            local dir = safe_normalize(ofs);
            local speed = 0.1f + len * 0.1f;

            .owner.move_input = v2(dir * speed);

            if (len < 64.0f)
            {
                break;
            }

            yield();
        }
    };

    AI.WaitActionThread = function()
    {
        while (threadIsAlive(.owner.action_thread))
        {
            yield();
        }
    };

    AI.TryAttack = function(entity)
    {
        local ofs = entity.pos - .owner.pos;
        local len = safe_length(ofs);
        local dir = safe_normalize(ofs);

        if (len > 96.0f)
        {
            sleep(0.2f);
            return;
        }

        sleep(0.2f);
        .WaitActionThread();
        local combo_data = PlayerGroundAttacks["PunchL"];
        .owner.Combo(combo_data);
        .WaitActionThread();
        local combo_data = PlayerGroundAttacks["PunchR"];
        .owner.Combo(combo_data);
        .WaitActionThread();
        sleep(0.2f);
        .WaitActionThread();
        local combo_data = PlayerGroundAttacks["Uppercut"];
        .owner.Combo(combo_data);
        .WaitActionThread();
        sleep(0.2f);
    };

    AI.update_thread = AI:thread(AI.Update);
    AI.owner.notify_release.Register(AI, AI.NotifyOwnerRelease);
    AI.owner.notify_take_damage.Register(AI, AI.NotifyOwnerTakeDamage);

    return AI;
};