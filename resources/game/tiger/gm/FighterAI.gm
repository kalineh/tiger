
global MakeFighterAI = function(owner, name)
{
    local AI = table();

    AI.owner = owner;
    AI.name = name;
    AI.action_thread = -1;

    AI.NotifyOwnerRelease = function()
    {
        threadKill(.update_thread);
        threadKill(.action_thread);

        return false;
    };

    AI.NotifyOwnerTakeDamage = function(damage)
    {
        threadKill(.action_thread);

        return true;
    };

    AI.Update = function()
    {
        while (true)
        {
            // TODO: player search
            //local target = .owner.world.FindNearestPlayer().pos;
            //local offset = target + v3(1.0f, 0.1f) * randfloat(-12.0f, 12.0f);
            //.MoveTo(.owner.pos + offset);

            local action_function = function()
            {
                .MoveToEntity(.owner.world.FindNearestPlayer());
            };

            .action_thread = this:thread(action_function);

            while (threadIsAlive(.action_thread))
            {
                yield();
            }

            sleep(randfloat(1.5f, 3.0f));
        }
    };

    AI.MoveToEntity = function(entity)
    {
        local limit = 60 * 6;

        while (true)
        {
            local target = entity.pos;
            local ofs = target - .owner.pos;
            local len = safe_length(ofs);
            local dir = safe_normalize(ofs);
            local speed = 0.1f + len * 0.01f;

            .owner.move_input = v2(dir * speed);

            g_dump.target = target;
            g_dump.ent = entity;

            if (len < 3.0f)
            {
                break;
            }

            if (randint(0, 1000) <= 2)
            {
                break;
            }

            yield();
        }
    };

    AI.MoveTo = function(target)
    {
        local limit = 60 * 6;

        while (true)
        {
            local ofs = target - .owner.pos;
            local len = safe_length(ofs);
            local dir = safe_normalize(ofs);
            local speed = 0.1f + len * 0.1f;

            .owner.move_input = v2(dir * speed);

            if (len < 3.0f)
            {
                break;
            }

            yield();
        }
    };

    AI.update_thread = AI:thread(AI.Update);
    AI.owner.notify_release.Register(AI, AI.NotifyOwnerRelease);
    AI.owner.notify_take_damage.Register(AI, AI.NotifyOwnerTakeDamage);

    return AI;
};