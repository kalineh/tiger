
global MakeFighterAI = function(owner, name)
{
    local AI = table();

    AI.owner = owner;
    AI.name = name;
    AI.action_thread = -1;

    AI.NotifyOwnerRelease = function()
    {
        threadKill(.update_thread);
        threadKill(.action_thread);

        return false;
    };

    AI.NotifyOwnerTakeDamage = function(damage)
    {
        threadKill(.action_thread);

        local delay_function = function()
        {
            sleep(0.5f);
        };

        .action_thread = this:thread(delay_function);

        return true;
    };

    AI.Update = function()
    {
        while (true)
        {
            // TODO: player search
            //local target = .owner.world.FindNearestPlayer().pos;
            //local offset = target + v3(1.0f, 0.1f) * randfloat(-12.0f, 12.0f);
            //.MoveTo(.owner.pos + offset);

            if (.owner.stun > 0)
            {
                sleep(0.25f);
                continue;
            }

            // TODO: use state instead of animation?
            if (.owner.anim.currAnimName == "knockdown" ||
                .owner.anim.currAnimName == "prone")
            {
                sleep(0.25f);
                continue;
            }

            local action_function = function()
            {
                local player = .owner.world.FindNearestPlayer();

                .MoveToEntity(player);
                .TryAttack(player);
            };

            .action_thread = this:thread(action_function);

            while (threadIsAlive(.action_thread))
            {
                yield();
            }

            sleep(randfloat(0.5f, 1.0f));
        }
    };

    AI.MoveToEntity = function(entity)
    {
        local limit = 60 * 6;

        while (true)
        {
            local target = entity.pos;
            local ofs = target - .owner.pos;
            local len = safe_length(ofs);
            local dir = safe_normalize(ofs);
            local speed = 0.1f + len * 0.01f;

            .owner.move_input = v2(dir * speed);

            if (abs(ofs.x) < 64.0f && abs(ofs.y) < 8.0f)
            {
                break;
            }

            if (randint(0, 1000) <= 2)
            {
                break;
            }

            yield();
        }
    };

    AI.MoveToPosition = function(position)
    {
        local limit = 60 * 6;

        while (true)
        {
            local ofs = position - .owner.pos;
            local len = safe_length(ofs);
            local dir = safe_normalize(ofs);
            local speed = 0.1f + len * 0.1f;

            .owner.move_input = v2(dir * speed);

            if (len < 64.0f)
            {
                break;
            }

            yield();
        }
    };

    AI.TryAttack = function(entity)
    {
        local ofs = entity.pos - .owner.pos;
        local len = safe_length(ofs);
        local dir = safe_normalize(ofs);

        //sleep(1.0f);
        //return;

        sleep(0.2f);
        local combo_data = PlayerGroundAttacks["PunchL"];
        .owner.Combo(combo_data);
        sleep(0.2f);
        local combo_data = PlayerGroundAttacks["PunchR"];
        .owner.Combo(combo_data);
        sleep(0.2f);
        local combo_data = PlayerGroundAttacks["Uppercut"];
        .owner.Combo(combo_data);
        sleep(0.2f);
    };

    AI.update_thread = AI:thread(AI.Update);
    AI.owner.notify_release.Register(AI, AI.NotifyOwnerRelease);
    AI.owner.notify_take_damage.Register(AI, AI.NotifyOwnerTakeDamage);

    return AI;
};