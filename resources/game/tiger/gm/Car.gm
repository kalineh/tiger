
global CarLaneY = {
    -240.0f,
    -326.0f,
};

global MakeCarAI = function(car)
{
    local AI = table();

    AI.car = car;

    AI.NotifyOwnerRelease = function()
    {
        threadKill(.update_thread);
        return false;
    };

    AI.Update = function()
    {
        // TODO: can just do with physics and 0.0f friction
        while (true)
        {
            if (.car.lane == 0)
            {
                .car.move_input = v2(-5.0f, 0.0f);
                .car.anim.facing = FACING.RIGHT;
            }
            else 
            {
                .car.move_input = v2(-0.2f, 0.0f);
            }

            // TODO: lane changes

            if (.car.pos.x < -900.0f)
            {
                .car.world.AddDeathRow(.car);
                return;
            }

            yield();
        }
    };

    AI.car.notify_release.Register(AI, AI.NotifyOwnerRelease);

    AI.update_thread = AI:thread(AI.Update);
    return AI;
};

global MakeCar = function(world, coord, car_type, lane)
{
	local Car = MakeEntity(world, coord);

    assert(?car_type);
    assert(?lane);

	Car.type = "Car";
	Car.controls = null;
	Car.color = Gfx.WHITE;
	Car.max_health = 1.0f;
	Car.max_energy = 1.0f;
	Car.health = Car.max_health;
	Car.energy = Car.max_energy;
	Car.mass = 2.0f;
	Car.anim = MakeSpriteAnimation(g_game.animBank, "cars");
	Car.move_input = v2();
    Car.air_move_speed = v2(1.0f, 0.5f);
    Car.ground_move_speed = v2(5.0f, 1.2f);
    Car.frames_ground = 0;
    Car.frames_air = 0;
    Car.action_thread = -1;
    Car.collision_body = MakeCollision(Car, CollisionType.Circle, 32.0f);
	Car.air_max_speed = v3(8.0f, 3.0f, 4.0f);
	Car.ground_max_speed = v3(8.0f, 3.0f, 4.0f);
	Car.notify_release = MakeNotify(this, "NotifyRelease");
	Car.notify_take_damage = MakeNotify(this, "NotifyTakeDamage");
    Car.constant_speed = v2();

    Car.lane = lane;
    Car.car_type = car_type;
    Car.collision_body.SetEnabled(true);
	Car.anim.ChangeTo("npc" + car_type);
    // TODO: offscreen right camera
    Car.pos = v3(Car.pos.x, CarLaneY[Car.lane], 0.0f);

    world.collision_manager.Add(Car.collision_body);

    Car.EntityRelease = Car.Release;
    Car.Release = function()
    {
        .notify_release.Notify();
        .world.collision_manager.Remove(.collision_body);
        threadKill(.action_thread);
        .EntityRelease();
    };

    Car.StartActionThread = function(name, f, a, b, c, d, e)
    {
        assert(!threadIsAlive(.action_thread));
        .action_thread = this:thread(f, a, b, c, d, e);
    };

    Car.StartActionThreadThis = function(this_, name, f, a, b, c, d, e)
    {
        assert(!threadIsAlive(.action_thread));
        .action_thread = this_:thread(f, a, b, c, d, e);
    };

    Car.SetNPCLane = function(lane)
    {
        local action_function = function(lane)
        {
            while (true)
            {
                if (lane == 0)
                {
                    .move_input = v2(-2.0f, 0.0f);
                    .anim.facing = FACING.LEFT;
                }
                else 
                {
                    .move_input = v2(-0.2f, 0.0f);
                }

                yield();
            }
        };
        .action_thread = this:thread(action_function, lane);
    };

	Car.OnPreUpdate = function()
	{
        local airborne = .IsAirborne();

        if (airborne)
        {
            .frames_ground = 0;
            .frames_air += 1;
        }
        else
        {
            .frames_ground += 1;
            .frames_air = 0;
        }

        if (!threadIsAlive(.action_thread))
        {
            local move = .move_input;
            local move_speed = .ground_move_speed;

            if (.IsAirborne())
            {
                move_speed = .air_move_speed;
            }

            move *= move_speed;

            .accel += v3(move);
        }

        .anim.speed = 1.0f;

        if (!threadIsAlive(.action_thread))
        {
            if (.frames_ground >= 1)
            {
                //if (.move_input.x < 0.0f) { .anim.facing = FACING.RIGHT; }
                //if (.move_input.x > 0.0f) { .anim.facing = FACING.LEFT; }

                local len = safe_length(.vel + .accel);

                if (len <= 0.01f )
                {
                    //.anim.ChangeToNoReset("idle");
                }
                else
                {
                    if (.move_input.x < 0.0f)
                    {
                        if (.vel.x > 0.0f)
                        {
                            //.anim.ChangeToNoReset("stop");
                        }
                        else
                        {
                            //.anim.ChangeToNoReset("move");
                        }
                    }
                    if (.move_input.x > 0.0f)
                    {
                        if (.vel.x < 0.0f)
                        {
                            //.anim.ChangeToNoReset("stop");
                        }
                        else
                        {
                            //.anim.ChangeToNoReset("move");
                        }
                    }

                    if (.anim.currAnimName == "move")
                    {
                        .anim.speed = abs(.vel.x) + abs(.vel.y);
                    }
                }
            }
            else // airborne
            {
                if (.vel.z < 0.0f)
                {
                    //.anim.ChangeToNoReset("fall");
                }
                else if (.vel.z > 0.0f)
                {
                    //.anim.ChangeToNoReset("jump");
                }
            }
        }

        .move_input = v2(0.0f, 0.0f);
	};

    Car.OnPostUpdate = function()
    {
        local center = .GetAnimCenter();
        local dir = .GetFacingDir();

        // TODO: facing is backwards?
        dir *= -1.0f;

        // TODO: why were we setting this here?
        //.collision_body.SetEnabled(true);

        .collision_body.SetPosition(center);
    };

    Car.OnTakeDamage = function(damage)
    {
        .notify_take_damage.Notify(damage);
    };

    Car.OnCollide = function(lhs, rhs)
    {
        if (rhs.owner.type == .type)
        {
            return;
        }

        if (lhs == .collision_body)
        {
            if (rhs == rhs.owner.collision_body)
            {
                local damage = 1.0f;

                .TakeDamage(damage);

                local ofs = .pos - rhs.owner.pos;
                local dir = safe_normalize(ofs * v3(1,0,0));
                local force = dir * 1.0f;

                .accel += v3(force.x, force.y, 0.0f);
            }
        }

        return false;
    };

    Car.OnDie = function()
    {
        // TODO: explosion!
    };

	return Car;
};