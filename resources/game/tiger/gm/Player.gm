
global PlayerDefaults =
{
	MaxHealth = 40.0f,
	MaxEnergy = 20.0f,
};

global MakeInput = function(press, hold, arg)
{
    assert(?press);
    assert(?hold);
    assert(?arg);

    local input = table();

    input.press = press;
    input.hold = hold;
    input.arg = arg;

    input.Press = function()
    {
        return .press(.arg);
    };
    
    input.Hold = function()
    {
        return .hold(.arg);
    };

	return input;
};

global PlayerControlsKeyboard =
{
	MoveFunction = MakeInput(function() {
		local result = v2(0.0f, 0.0f);
		if (Input.IsKeyDown("UP")) { result += v2(0.0f, +1.0f); }
		if (Input.IsKeyDown("DOWN")) { result += v2(0.0f, -1.0f); }
		if (Input.IsKeyDown("LEFT")) { result += v2(-1.0f, 0.0f); }
		if (Input.IsKeyDown("RIGHT")) { result += v2(+1.0f, 0.0f); }
		return result;
    }, function() { return null; }, {}),

	Jump = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "X"),
	Punch = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "C"),
	Kick = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "Z"),
	Guard = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "D"),
	Slide = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "V"),
};

global ComboActions =
{
    Punch = 0,
    Kick = 1,
    Block = 2,
    Up = 3,
    Down = 4,
    Forward = 5,
    Backward = 6,
}; 

global PlayerGroundCombos =
{
    PunchL =
    {
        sequence = { 0 },
        anim = "punchl",
        damage = 1.0f,
        finish = false,
        stuns = false,
    },

    PunchR =
    {
        sequence = { 0,0 },
        anim = "punchr",
        damage = 1.0f,
        finish = false,
        stuns = false,
    },

    PunchL2 =
    {
        sequence = { 0,0,0 },
        anim = "punchl",
        damage = 1.0f,
        finish = false,
        stuns = false,
    },

    Kick =
    {
        sequence = { 1 },
        anim = "kick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },

    Knee =
    {
        sequence = { 0,0,5,1 },
        anim = "knee",
        damage = 1.0f,
        finish = true,
        stuns = true,
    },

    SpinKick =
    {
        sequence = { 0,0,0,1 },
        anim = "spinkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },

    SweepKick =
    {
        sequence = { 0,0,4,1 },
        anim = "sweepkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },
};

global PlayerAirCombos =
{
    JumpKick =
    {
        sequence = { 1 },
        anim = "jumpkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },
};

global MakeComboSystem = function(data)
{
    assert(?data);

    local combo = table();

    combo.data = data;
    combo.sequence = table();
    combo.wait_thread = -1;
    combo.reset_thread = -1;
    combo.used_current_combo = false;

    combo.TryAddInput = function(action, input)
    {
        assert(?action);
        assert(?input);

        if (threadIsAlive(.wait_thread))
        {
            return;
        }

        .sequence[tableCount(.sequence)] = action;

        .WaitInput(input);
        .StartResetCountdown();

        .used_current_combo = false;
    };

    combo.Reset = function()
    {
        tableClear(.sequence);
        threadKill(.wait_thread);
    };

    combo.StartResetCountdown = function()
    {
        threadKill(.reset_thread);

        local reset_function = function()
        {
            sleep(0.4f);
            tableClear(.sequence);
        };

        .reset_thread = this:thread(reset_function);
    };

    combo.WaitInput = function(input)
    {
        if (threadIsAlive(.wait_thread))
        {
            return;
        }

        local wait_function = function(input)
        {
            while (input.Hold())
            {
                yield();
            }
        };

        .wait_thread = this:thread(wait_function, input);
    };

    combo.GetCombo = function()
    {
        if (.used_current_combo)
        {
           return null;
        }

        local best_length = 0;
        local best_combo = null;

        foreach (name and data in .data)
        {
            if (tableCount(.sequence) < tableCount(data.sequence))
            {
                continue;
            }

            for (i = 0; i < tableCount(data.sequence); i += 1)
            {
                local current = .sequence[i];
                local desired = data.sequence[i];

                if (current != desired)
                {
                    break;    
                }

                if (i == tableCount(data.sequence) - 1)
                {
                    if (tableCount(data.sequence) > best_length)
                    {
                        best_combo = name;
                        best_length = tableCount(data.sequence);;
                    }
                }
            }
        }

        if (?best_combo)
        {
            .used_current_combo = true;
        }

        return best_combo;
    };

    return combo;
};

global MakePlayerController = function(fighter)
{
    assert(?fighter);

	local Controller = table();

	Controller.fighter = fighter;
	Controller.controls = PlayerControlsKeyboard;

	Controller.Update = function()
	{
        while (true)
        {
            local f = .fighter;

            f.move_input = .controls.MoveFunction.Press();

            if (f.frames_ground > 0)
            {
                if (.controls.Jump.Press())
                {
                    f.Jump(.controls.Jump);
                }
            }

            g_dump.combo = f.ground_combo;
            g_dump.sequence = StringTableValues(f.ground_combo.sequence);

            // TODO: jump version
            if (!threadIsAlive(f.action_thread))
            {
                if (.controls.Punch.Press())
                {
                    f.ground_combo.TryAddInput(ComboActions.Punch, .controls.Punch);
                }
                else if (.controls.Kick.Press())
                {
                    f.ground_combo.TryAddInput(ComboActions.Kick, .controls.Kick);
                }

                local combo_name = f.ground_combo.GetCombo();
                if (?combo_name)
                {
                    g_dump.last_combo = combo_name;

                    local combo_data = PlayerGroundCombos[combo_name];

                    f.Combo(combo_data);
                }
            }

            yield();
        }
	};

    Controller:thread(Controller.Update);

	return Controller;
};

global MakePlayer = function(world, coord)
{
	local Player = MakeFighter(world, coord, "Player");

	Player.mass = 2.0f;

    // TODO: move to config
	Player.air_max_speed = v3(6.0f, 4.0f, 8.0f);
	Player.ground_max_speed = v3(6.0f, 4.0f, 8.0f);
	Player.air_friction = v3(1.0f, 1.0f, 0.9f);
	Player.ground_friction = v3(0.8f, 0.8f, 0.9f);

	Player.controls = PlayerControlsKeyboard;
    Player.ground_combo = MakeComboSystem(PlayerGroundCombos);
    Player.air_combo = MakeComboSystem(PlayerAirCombos);

	Player.BaseOnUpdate = Player.OnUpdate;
	Player.OnUpdate = function()
	{
        .BaseOnUpdate();

		g_game.state.cam.SetTargetPos( v2(.pos) );
	};

	return Player;
};
