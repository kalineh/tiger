
global PlayerDefaults =
{
	MaxHealth = 40.0f,
	MaxEnergy = 20.0f,
	HealthRegen = 0.0f,
	EnergyRegen = 0.0f,
};

global MakePlayer = function(world, coord)
{
	local Player = MakeEntity(world, coord);

	Player.type = EntityType.Player;
	Player.color = Gfx.WHITE;
	Player.max_health = PlayerDefaults.MaxHealth;
	Player.max_energy = PlayerDefaults.MaxEnergy;
	Player.health_regen = PlayerDefaults.HealthRegen;
	Player.energy_regen = PlayerDefaults.EnergyRegen;
	Player.health = Player.max_health;
	Player.energy = Player.max_energy;
	Player.anim = MakeSpriteAnimation(g_game.animBank, "player");
	Player.move_input = v2();
    Player.move_speed = v2(4.0f, 3.0f);

	Player.OnTickTurn = function()
	{
		.health = min(.max_health, .health + .health_regen);
		.energy = min(.max_energy, .energy + .energy_regen);
	};

	Player.BaseDraw = Player.Draw;
	Player.Draw = function()
	{
        .BaseDraw();

		// low health, draw particles
		if ( .health <= 10 )
		{
			if ( randint(0,5)==0 )
			{
				g_game.state.EmitParticlesAt("playerTakeDamage", .GetCenterWorld(), 1);
			}

			// fire
			Gfx.Color(Gfx.WHITE, 0.6f);
			.animFire.Draw(p+.draw_offset + v2(-32.0f, -12.0f ) );
		}
	};

	Player.OnTakeDamage = function(damage)
	{
		g_game.soundBanks["game"].Play("playerTakeDamage");
		g_game.state.EmitParticlesAt("playerTakeDamage", .GetCenterWorld(), 16);
		.Shake(3.0f, 0.2f);
	};

	Player.OnUpdate = function()
	{
		g_game.state.cam.SetTargetPos( .pos );
		._UpdateInput();
        ._UpdateMove();
	};

	Player._InitInputs = function()
	{
		.inputsMovement = 
		{
			C = { fun = function() { return .InputAttack(0); }, arg = null, },
			X = { fun = function() { return .InputJump(); }, arg = null, },
			Y = { fun = function() { return .InputAttack(1); }, arg = null, },
        };

		.inputs = tableDuplicate(.inputsMovement);
	};

	Player._UpdateInput = function()
	{
        .move_input = .GetDirectionalInput();

		foreach (k and v in .inputs)
		{
			if (Input.IsKeyDown(k))
			{
				local fun = v.fun;
				local arg = v.arg;

				this:fun(arg);
			}
		}
	};
    
    Player._UpdateMove = function()
    {
        local dir = .move_input;
        local move = dir * .move_speed;

        .accel += move;
    };

	Player.InputAttack = function(type)
	{
        // anim
        // enable punch collision
        // update combo stuff
	};

	Player.InputJump = function(type)
	{
        if ( .height > 0.0f )
        {
            return;
        }

        // TODO: multi-frame hold down, cancel for end jump
        fork { 
            for (i = 0; i < 8; i += 1)
            {
                .height_accel += 8.0f;
                yield();
            }
        }
	};

	Player.GetDirectionalInput = function(allow_diagonal, fallback)
	{
		if (!?fallback)
		{
			fallback = v2(0.0f);
		}

        local dir = fallback;

        if (Input.IsKeyDown("UP") || Input.IsKeyDown("KP8") || Input.IsKeyDown("KP7") || Input.IsKeyDown("KP9"))
        {
            dir += v2(0.0f, +1.0f);
        }

        if (Input.IsKeyDown("DOWN") || Input.IsKeyDown("KP2") || Input.IsKeyDown("KP1") || Input.IsKeyDown("KP3"))
        {
            dir += v2(0.0f, -1.0f);
        }

		if (Input.IsKeyDown("LEFT") || Input.IsKeyDown("KP4") || Input.IsKeyDown("KP7") || Input.IsKeyDown("KP1"))
        {
            dir += v2(-1.0f, 0.0f);
        }
        
		if (Input.IsKeyDown("RIGHT") || Input.IsKeyDown("KP6") || Input.IsKeyDown("KP9") || Input.IsKeyDown("KP3"))
        {
            dir += v2(+1.0f, 0.0f);
        }

		return dir;
	};

	Player.OnDie = function()
	{
		// zoom in death
		Tween.To(g_game.state.cam,  1.0f, {zoom=1.5});

		g_game.state.OnGameOver();

		// TEMPORARY: just make enemies walk around for funsies
		local postdie = function()
		{
			while (true)
			{
				.world.ReadyToTickTurn();
				sleep(0.5f);
			}
		};

		this:thread(postdie);
	};

	Player._InitInputs();

	return Player;
};
