
global PlayerDefaults =
{
	MaxHealth = 40.0f,
	MaxEnergy = 20.0f,
};

global MakeInput = function(press, hold, arg)
{
    assert(?press);
    assert(?hold);
    assert(?arg);

    local input = table();

    input.press = press;
    input.hold = hold;
    input.arg = arg;

    input.Press = function()
    {
        return .press(.arg);
    };
    
    input.Hold = function()
    {
        return .hold(.arg);
    };

	return input;
};

global PlayerControlsKeyboard =
{
	MoveFunction = MakeInput(function() {
		local result = v2(0.0f, 0.0f);
		if (Input.IsKeyDown("UP")) { result += v2(0.0f, +1.0f); }
		if (Input.IsKeyDown("DOWN")) { result += v2(0.0f, -1.0f); }
		if (Input.IsKeyDown("LEFT")) { result += v2(-1.0f, 0.0f); }
		if (Input.IsKeyDown("RIGHT")) { result += v2(+1.0f, 0.0f); }
		return result;
    }, function() { return null; }, {}),

	Jump = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "X"),
	Punch = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "C"),
	Kick = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "Z"),
	Guard = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "D"),
	Slide = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "V"),
};

global PlayerGroundAttacks =
{
    Punch1 =
    {
        anim = "punchl",
        damage = 1.0f,
        finish = false,
        stuns = false,
    },

    Punch2 =
    {
        anim = "punchr",
        damage = 1.0f,
        finish = false,
        stuns = false,
    },

    Punch3 =
    {
        anim = "punchl",
        damage = 1.0f,
        finish = false,
        stuns = false,
    },

    Kick =
    {
        anim = "kick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },

    Knee =
    {
        anim = "knee",
        damage = 1.0f,
        finish = true,
        stuns = true,
    },

    SpinKick =
    {
        anim = "spinkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },

    SweepKick =
    {
        anim = "sweepkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },
};

global ComboActions =
{
    Punch = 0x01,
    Kick = 0x02,
    Block = 0x04,
    Up = 0x08,
    Down = 0x10,
    Forward = 0x20,
    Backward = 0x40,
}; 

global PlayerGroundComboChains =
{
    Default = {
        Punch1 = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    Punch1 = {
        Punch2 = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    Punch2 = {
        Punch3 = ComboActions.Punch,
        Kick = ComboActions.Kick,
        Knee = ComboActions.Kick | ComboActions.Forward,
    },

    Punch3 = {
        SpinKick = ComboActions.Kick,
        Punch1 = ComboActions.Punch,
    },

    Kick = {
        Punch1 = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    SpinKick = {
        Punch1 = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    Knee = {
        Punch1 = ComboActions.Punch,
    },
};

global PlayerAirCombos =
{
    JumpKick =
    {
        anim = "jumpkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },
};

global MakeComboSystem = function(chains, attacks)
{
    assert(?chains);
    assert(?chains.Default);
    assert(?attacks);

    local combo = table();

    combo.data = data;
    combo.chains = chains;
    combo.attacks = attacks;;
    combo.current = chains.Default;
    combo.actions = table();
    combo.wait_thread = -1;
    combo.reset_thread = -1;
    combo.used_current_combo = false;

    combo.TryAddInput = function(action, input)
    {
        assert(?action);
        assert(?input);

        if (threadIsAlive(.wait_thread))
        {
            return;
        }

        .actions[tableCount(.actions)] = action;

        .WaitInput(input);
        .StartResetCountdown();

        .used_current_combo = false;
    };

    combo.Reset = function()
    {
        .current = .chains.Default;
        tableClear(.actions);
        threadKill(.wait_thread);
        threadKill(.reset_thread);
    };

    combo.StartResetCountdown = function()
    {
        threadKill(.reset_thread);

        local reset_function = function()
        {
            sleep(0.4f);
            .chain = null;
        };

        .reset_thread = this:thread(reset_function);
    };

    combo.WaitInput = function(input)
    {
        // TODO: can probably remove

        if (threadIsAlive(.wait_thread))
        {
            return;
        }

        local wait_function = function(input)
        {
            while (input.Hold())
            {
                yield();
            }
        };

        .wait_thread = this:thread(wait_function, input);
    };

    combo.GetCombo = function()
    {
        if (.used_current_combo)
        {
           return null;
        }

        foreach (next and action in .current)
        {
            // TODO: combined flag handling
            foreach (a in .actions)
            {
                if ((action & a) == action)
                {
                    .used_current_combo = true;
                    .current = .chains[next];
                    tableClear(.actions);
                    return next;
                }
            }
        }

        return null;
    };

    return combo;
};

global MakePlayerController = function(fighter)
{
    assert(?fighter);

	local Controller = table();

	Controller.fighter = fighter;
	Controller.controls = PlayerControlsKeyboard;
    Controller.queue = table();

    Controller.QueueComboAction = function(combo, action, control)
    {
        if (!?.queue[action])
        {
            .queue[action] = table();
        }

        .queue[action].valid = true;
        .queue[action].combo = combo;
        .queue[action].action = action;
        .queue[action].control = control;
    };

    Controller.ProcessComboActions = function()
    {
        foreach (name and index in ComboActions)
        {
            local entry = .queue[index];
            if (!?entry) { continue; }
            if (!entry.valid) { continue; }

            entry.combo.TryAddInput(entry.action, entry.control);
        }

        foreach (entry in .queue)
        {
            entry.valid = false;
        }
    };

	Controller.Update = function()
	{
        while (true)
        {
            local f = .fighter;

            f.move_input = .controls.MoveFunction.Press();

            if (f.frames_ground > 0)
            {
                if (.controls.Jump.Press())
                {
                    f.Jump(.controls.Jump);
                }
            }

            g_dump.combo = f.ground_combo;
            g_dump.sequence = StringTableValues(f.ground_combo.actions);

            // TODO: jump version
            if (.controls.Punch.Press())
            {
                .QueueComboAction(f.ground_combo, ComboActions.Punch, .controls.Punch);
            }
            else if (.controls.Kick.Press())
            {
                .QueueComboAction(f.ground_combo, ComboActions.Kick, .controls.Kick);
            }

            if (!threadIsAlive(f.action_thread))
            {
                .ProcessComboActions();

                local combo_name = f.ground_combo.GetCombo();
                if (?combo_name)
                {
                    g_dump.last_combo = combo_name;

                    local combo_data = PlayerGroundAttacks[combo_name];

                    f.Combo(combo_data);
                }
            }

            yield();
        }
	};

    Controller:thread(Controller.Update);

	return Controller;
};

global MakePlayer = function(world, coord)
{
	local Player = MakeFighter(world, coord, "Player");

	Player.mass = 2.0f;

    // TODO: move to config
	Player.air_max_speed = v3(6.0f, 4.0f, 8.0f);
	Player.ground_max_speed = v3(6.0f, 4.0f, 8.0f);
	Player.air_friction = v3(1.0f, 1.0f, 0.9f);
	Player.ground_friction = v3(0.8f, 0.8f, 0.9f);

	Player.controls = PlayerControlsKeyboard;
    Player.ground_combo = MakeComboSystem(PlayerGroundComboChains, PlayerGroundAttacks);
    Player.air_combo = MakeComboSystem(PlayerGroundComboChains, PlayerGroundAttacks);

	Player.BaseOnUpdate = Player.OnUpdate;
	Player.OnUpdate = function()
	{
        .BaseOnUpdate();

		g_game.state.cam.SetTargetPos( v2(.pos) );
	};

	return Player;
};
