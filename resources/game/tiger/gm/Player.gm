
global PlayerDefaults =
{
	MaxHealth = 40.0f,
	MaxEnergy = 20.0f,
	HealthRegen = 0.0f,
	EnergyRegen = 0.0f,
};

global MakePlayer = function(world, coord)
{
	local Player = MakeEntity(world, coord);

	Player.type = EntityType.Player;
	Player.color = Gfx.WHITE;
	Player.pending_move = v2(0.0f);
	Player.max_health = PlayerDefaults.MaxHealth;
	Player.max_energy = PlayerDefaults.MaxEnergy;
	Player.health_regen = PlayerDefaults.HealthRegen;
	Player.energy_regen = PlayerDefaults.EnergyRegen;
	Player.health = Player.max_health;
	Player.energy = Player.max_energy;
	Player.anim = MakeSpriteAnimation(g_game.animBank, "player");

	Player.OnTickTurn = function()
	{
		.health = min(.max_health, .health + .health_regen);
		.energy = min(.max_energy, .energy + .energy_regen);
	};

	Player.Draw = function()
	{
        local jumpOffset = 0.0f;
        local drawPosition = .pos + v2(0.0f, jumpOffset);

		Gfx.Color(.color, .alpha);
		.anim.Draw( drawPosition );

		// low health, draw particles
		if ( .health <= 10 )
		{
			if ( randint(0,5)==0 )
			{
				g_game.state.EmitParticlesAt("playerTakeDamage", .GetCenterWorld(), 1);
			}

			// fire
			Gfx.Color(Gfx.WHITE, 0.6f);
			.animFire.Draw(p+.drawOffset + v2(-32.0f, -12.0f ) );
		}
	};

	Player.OnTakeDamage = function(damage)
	{
		g_game.soundBanks["game"].Play("playerTakeDamage");
		g_game.state.EmitParticlesAt("playerTakeDamage", .GetCenterWorld(), 16);
		.Shake(3.0f, 0.2f);
	};

	Player.OnUpdate = function()
	{
		g_game.state.cam.SetTargetPos( .pos );
		._UpdateInput();
	};

	Player._InitInputs = function()
	{
		.inputsMovement = 
		{
			UP = { fun = function() { return .InputMove(+0.0f, +1.0f); }, arg = null },
			DOWN = { fun = function() { return .InputMove(+0.0f, -1.0f); }, arg = null },
			LEFT = { fun = function() { return .InputMove(-1.0f, +0.0f); }, arg = null },
			RIGHT = { fun = function() { return .InputMove(+1.0f, +0.0f); }, arg = null },
			KP1 = { fun = function() { return .InputMove(-1.0f, -1.0f); }, arg = null },
			KP2 = { fun = function() { return .InputMove(+0.0f, -1.0f); }, arg = null },
			KP3 = { fun = function() { return .InputMove(+1.0f, -1.0f); }, arg = null },
			KP4 = { fun = function() { return .InputMove(-1.0f, +0.0f); }, arg = null },
			KP5 = { fun = function() { return .InputWait(); }, arg = null },
			KP6 = { fun = function() { return .InputMove(+1.0f, +0.0f); }, arg = null },
			KP7 = { fun = function() { return .InputMove(-1.0f, +1.0f); }, arg = null },
			KP8 = { fun = function() { return .InputMove(+0.0f, +1.0f); }, arg = null },
			KP9 = { fun = function() { return .InputMove(+1.0f, +1.0f); }, arg = null },
			SPACE = { fun = function() { return .InputWait(); }, arg = null, },
			E = { fun = function() { return .InputEscape(); }, arg = null, },
        };

		.inputs = tableDuplicate(.inputsMovement);
	};

	Player._UpdateInput = function()
	{
		foreach (k and v in .inputs)
		{
			if (Input.IsKeyDown(k))
			{
				local fun = v.fun;
				local arg = v.arg;

				this:fun(arg);
			}
		}
	};

	Player.InputMove = function(x, y)
	{		
        local move = v2(x, y);

		.pos += move;
	};

	Player.InputWait = function()
	{
		.pending_move = v2(0.0f);
		return true;
	};

	Player.GetDirectionalInput = function(allow_diagonal, fallback)
	{
		if (Input.DidKeyJustGoDown("UP")) { return v2(0.0f, +1.0f); }
		if (Input.DidKeyJustGoDown("DOWN")) { return v2(0.0f, -1.0f); }
		if (Input.DidKeyJustGoDown("LEFT")) { return v2(-1.0f, 0.0f); }
		if (Input.DidKeyJustGoDown("RIGHT")) { return v2(+1.0f, 0.0f); }

		if (Input.DidKeyJustGoDown("KP8")) { return v2(0.0f, +1.0f); }
		if (Input.DidKeyJustGoDown("KP2")) { return v2(0.0f, -1.0f); }
		if (Input.DidKeyJustGoDown("KP4")) { return v2(-1.0f, 0.0f); }
		if (Input.DidKeyJustGoDown("KP6")) { return v2(+1.0f, 0.0f); }

		if (allow_diagonal)
		{
			if (Input.DidKeyJustGoDown("KP7")) { return v2(-1.0f, +1.0f); }
			if (Input.DidKeyJustGoDown("KP9")) { return v2(+1.0f, +1.0f); }
			if (Input.DidKeyJustGoDown("KP3")) { return v2(+1.0f, -1.0f); }
			if (Input.DidKeyJustGoDown("KP1")) { return v2(-1.0f, -1.0f); }
		}

		if (!?fallback)
		{
			fallback = v2(0.0f);
		}

		return fallback;
	};

	Player.OnDie = function()
	{
		// zoom in death
		Tween.To(g_game.state.cam,  1.0f, {zoom=1.5});

		g_game.state.OnGameOver();

		// TEMPORARY: just make enemies walk around for funsies
		local postdie = function()
		{
			while (true)
			{
				.world.ReadyToTickTurn();
				sleep(0.5f);
			}
		};

		this:thread(postdie);
	};

	Player._InitInputs();

	return Player;
};
