
global PlayerDefaults =
{
	MaxHealth = 40.0f,
	MaxEnergy = 20.0f,
	HealthRegen = 0.0f,
	EnergyRegen = 0.0f,
};

global MakeInput = function(f, a)
{
    local input = table();

    assert(?f);
    //assert(?a);

    input.fun = f;
    input.arg = a;

    // TODO: better name
    input.Check = function()
    {
        return .fun(.arg);
    };

	return input;
};

global PlayerControlsKeyboard =
{
	MoveFunction = MakeInput(function() {
		local result = v2(0.0f, 0.0f);
		if (Input.IsKeyDown("UP")) { result += v2(0.0f, +1.0f); }
		if (Input.IsKeyDown("DOWN")) { result += v2(0.0f, -1.0f); }
		if (Input.IsKeyDown("LEFT")) { result += v2(-1.0f, 0.0f); }
		if (Input.IsKeyDown("RIGHT")) { result += v2(+1.0f, 0.0f); }
		return result;
	}, null),

	Jump = MakeInput(Input.IsKeyDown, "X"),
	AttackPunch = MakeInput(Input.IsKeyDown, "C"),
	AttackKick = MakeInput(Input.IsKeyDown, "Z"),
	Slide = MakeInput(Input.IsKeyDown, "V"),
};

global MakePlayer = function(world, coord)
{
	local Player = MakeEntity(world, coord);

	Player.controls = PlayerControlsKeyboard;
	Player.type = EntityType.Player;
	Player.color = Gfx.WHITE;
	Player.max_health = PlayerDefaults.MaxHealth;
	Player.max_energy = PlayerDefaults.MaxEnergy;
	Player.health_regen = PlayerDefaults.HealthRegen;
	Player.energy_regen = PlayerDefaults.EnergyRegen;
	Player.health = Player.max_health;
	Player.energy = Player.max_energy;
	Player.anim = MakeSpriteAnimation(g_game.animBank, "player");
	Player.move_input = v2();
    Player.move_speed = v2(4.0f, 3.0f);

	Player.OnTickTurn = function()
	{
		.health = min(.max_health, .health + .health_regen);
		.energy = min(.max_energy, .energy + .energy_regen);
	};

	Player.BaseDraw = Player.Draw;
	Player.Draw = function()
	{
        .BaseDraw();
	};

	Player.OnTakeDamage = function(damage)
	{
		g_game.soundBanks["game"].Play("playerTakeDamage");
		g_game.state.EmitParticlesAt("playerTakeDamage", .GetCenterWorld(), 16);
		.Shake(3.0f, 0.2f);
	};

	Player.IsInput = function(control)
	{
		local f = control[0];
		local a = control[1];
		local active = f(a);
		return active;
	};

	Player.OnUpdate = function()
	{
		g_game.state.cam.SetTargetPos( v2(.pos) );

        local move = .controls.MoveFunction.Check();

        move *= .move_speed;

        .accel += v3(move);

        if (.controls.Jump.Check())
        {
            .TryJump();
        }

        if (.controls.AttackPunch.Check())
        {
            if (.IsAirborne())
            {
                .TryJumpAttack();
            }
        }
        else
        {
            .TryAttack();
        }
	};

    Player.TryJump = function()
    {
        if ( threadIsAlive(.jump_thread) )
        {
            return;
        }

        local jump_function = function()
        {
            // TODO: allow cancel attack

            local jump_min_frames = 8;
            local jump_frames = 32;
            local jump_force = 4.0f;
            local jump_falloff = 0.2f;

            for (i = 0; i < jump_frames; i += 1)
            {
                if (i >= jump_min_frames)
                {
                    if (.controls.Jump.Check() == false)
                    {
                        break;
                    }
                }

                .accel += v3(0.0f, 0.0f, jump_force);

                jump_force = max( 0.0f, jump_force - jump_falloff );

                yield();
            }

            while (.controls.Jump.Check() == true)
            {
                yield();
            }

            while (.IsAirborne())
            {
                yield();
            }
        };

        .jump_thread = this:thread(jump_function);
    };

    Player.CancelAttack = function()
    {
        // reset anim
        // kill thread
        assert(false);
    };

    Player.TryAttack = function(type)
    {
        if (threadIsAlive(.attack_thread))
        {
            return;
        }

        local attack_function = function(attack_type)
        {
            // enable punch collision

            while (.anim.IsFinished() == false)
            {
                yield();
            }

            // disable punch collision

            //.combo_sequence[] = attack_type;

            // wait for combos
            // maybe spawn thread and sleep till combo reset
            // drop out of attack to allow another attack
        };

        .attack_thread = this:thread(attack_function, attack_type);
    };
    
    Player.TryJumpAttack = function()
    {
        assert(.IsAirborne());

        if (threadIsAlive(.attack_thread))
        {
            return;
        }

        local attack_function = function(attack_type)
        {
            // enable punch collision

            while (.anim.IsFinished() == false)
            {
                yield();
            }

            // disable punch collision

            //.combo_sequence[] = attack_type;

            // wait for combos
            // maybe spawn thread and sleep till combo reset
            // drop out of attack to allow another attack
        };

        .attack_thread = this:thread(attack_function, attack_type);
    };
    
	Player.OnDie = function()
	{
		// zoom in death
		Tween.To(g_game.state.cam,  1.0f, {zoom=1.5});

		g_game.state.OnGameOver();

		// TEMPORARY: just make enemies walk around for funsies
		local postdie = function()
		{
			while (true)
			{
				.world.ReadyToTickTurn();
				sleep(0.5f);
			}
		};

		this:thread(postdie);
	};

	return Player;
};
