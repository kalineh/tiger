
global PlayerDefaults =
{
	MaxHealth = 40.0f,
	MaxEnergy = 20.0f,
};

global MakeInput = function(press, hold, arg)
{
    assert(?press);
    assert(?hold);
    assert(?arg);

    local input = table();

    input.press = press;
    input.hold = hold;
    input.arg = arg;

    input.Press = function()
    {
        return .press(.arg);
    };
    
    input.Hold = function()
    {
        return .hold(.arg);
    };

	return input;
};

global PlayerControlsKeyboard =
{
	MoveFunction = MakeInput(function() {
		local result = v2(0.0f, 0.0f);
		if (Input.IsKeyDown("UP")) { result += v2(0.0f, +1.0f); }
		if (Input.IsKeyDown("DOWN")) { result += v2(0.0f, -1.0f); }
		if (Input.IsKeyDown("LEFT")) { result += v2(-1.0f, 0.0f); }
		if (Input.IsKeyDown("RIGHT")) { result += v2(+1.0f, 0.0f); }
		return result;
    }, function() { return null; }, {}),

	Jump = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "X"),
	Punch = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "C"),
	Kick = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "Z"),
	Block = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "D"),
	Throw = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "V"),
	Up = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "UP"),
	Down = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "DOWN"),
	Left = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "LEFT"),
	Right = MakeInput(Input.DidKeyJustGoDown, Input.IsKeyDown, "RIGHT"),
};

global PlayerGroundAttacks =
{
    PunchL =
    {
        anim = "punchl",
        damage = 1.0f,
        finish = false,
        stun = 0,
        push = 0.1f,
        knockback = 0.0f,
        knockup = 1.5f,
        projectile = null,
    },

    PunchR =
    {
        anim = "punchr",
        damage = 1.0f,
        finish = false,
        stun = 0,
        push = 0.1f,
        knockback = 0.0f,
        knockup = 1.5f,
        projectile = null,
    },

    Uppercut =
    {
        anim = "uppercut",
        damage = 1.0f,
        finish = false,
        stun = 0,
        push = 0.1f,
        knockback = 1.5f,
        knockup = 1.5f,
        projectile = null,
    },

    Kick =
    {
        anim = "kick",
        damage = 2.0f,
        finish = false,
        stun = 0,
        push = 0.5f,
        knockback = 1.0f,
        knockup = 10.0f,
        projectile = null,
    },

    Knee =
    {
        anim = "knee",
        damage = 1.0f,
        finish = true,
        stun = 8,
        push = 2.0f,
        knockback = 1.0f,
        knockup = 8.0f,
        projectile = null,
    },

    SpinKick =
    {
        anim = "spinkick",
        damage = 2.0f,
        finish = true,
        stun = 2,
        push = -0.1f,
        knockback = 0.0f,
        knockup = 2.0f,
        projectile = null,
    },

    SweepKick =
    {
        anim = "sweepkick",
        damage = 2.0f,
        finish = true,
        stun = 0,
        push = 6.0f,
        knockback = 0.0f,
        knockup = 1.1f,
        projectile = null,
    },

    AfroPick =
    {
        anim = "throw",
        damage = 0.0f,
        finish = false,
        stun = 0,
        push = 0.0f,
        knockback = 0.0f,
        knockup = 0.0f,
        projectile = "afropick",
    },
};

global ComboActions =
{
    Punch = 0x01,
    Kick = 0x02,
    Block = 0x04,
    Throw = 0x08,
    Up = 0x10,
    Down = 0x20,
    Forward = 0x40,
    Backward = 0x80,
}; 

global PlayerGroundComboChains =
{
    Default = {
        AfroPick = ComboActions.Throw,
        PunchL = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    AfroPick = {
        AfroPick = ComboActions.Throw,
        PunchL = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    PunchL = {
        PunchR = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    PunchR = {
        Knee = ComboActions.Kick | ComboActions.Forward,
        Uppercut = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    Uppercut = {
        SpinKick = ComboActions.Kick,
        PunchL = ComboActions.Punch,
    },

    Kick = {
        SweepKick = ComboActions.Kick | ComboActions.Down,
        PunchL = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    SpinKick = {
        PunchL = ComboActions.Punch,
        Kick = ComboActions.Kick,
    },

    Knee = {
        PunchL = ComboActions.Punch,
    },
};

global PlayerAirCombos =
{
    JumpKick =
    {
        anim = "jumpkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },
};

global MakeComboSystem = function(chains, attacks)
{
    assert(?chains);
    assert(?chains.Default);
    assert(?attacks);

    local combo = table();

    combo.data = data;
    combo.chains = chains;
    combo.attacks = attacks;;
    combo.current = chains.Default;
    combo.actions = table();
    combo.wait_thread = -1;
    combo.reset_thread = -1;
    combo.used_current_combo = false;

    combo.TryAddInput = function(action, input)
    {
        assert(?action);
        assert(?input);

        if (threadIsAlive(.wait_thread))
        {
            return;
        }

        .actions[tableCount(.actions)] = action;

        .WaitInput(input);
        .StartResetCountdown();

        .used_current_combo = false;
    };

    combo.Reset = function()
    {
        .current = .chains.Default;
        tableClear(.actions);
        threadKill(.wait_thread);
        threadKill(.reset_thread);
    };

    combo.StartResetCountdown = function()
    {
        threadKill(.reset_thread);

        local reset_function = function()
        {
            sleep(0.35f);
            // beware of reset thread kill order killing this thread
            .Reset();
        };

        .reset_thread = this:thread(reset_function);
    };

    combo.WaitInput = function(input)
    {
        // TODO: can probably remove

        if (threadIsAlive(.wait_thread))
        {
            return;
        }

        local wait_function = function(input)
        {
            while (input.Hold())
            {
                yield();
            }
        };

        .wait_thread = this:thread(wait_function, input);
    };

    combo.GetCombo = function()
    {
        if (.used_current_combo)
        {
           return null;
        }

        foreach (next and action in .current)
        {
            foreach (a in .actions)
            {
                if ((action & a) == action)
                {
                    .used_current_combo = true;
                    .current = .chains[next];
                    tableClear(.actions);
                    return next;
                }
            }
        }

        return null;
    };

    return combo;
};

global MakePlayerController = function(fighter)
{
    assert(?fighter);

	local Controller = table();

	Controller.fighter = fighter;
	Controller.controls = PlayerControlsKeyboard;
    Controller.queue = table();

    Controller.QueueComboAction = function(combo, action, control)
    {
        if (!?.queue[action])
        {
            .queue[action] = table();
        }

        .queue[action].valid = true;
        .queue[action].combo = combo;
        .queue[action].action = action;
        .queue[action].control = control;
    };

    Controller.ProcessComboActions = function()
    {
        foreach (item in .queue)
        {
            if (item.valid)
            {
                item.combo.TryAddInput(item.action, item.control);
            }

            item.valid = false;
        }
    };

	Controller.Update = function()
	{
        while (true)
        {
            local f = .fighter;

            if (f.IsDead())
            {
                yield();
                continue;
            }

            f.move_input = .controls.MoveFunction.Press();

            if (f.frames_ground > 0)
            {
                // we may still be on the ground for a frame while jump is still active
                // so ignore if the jump thread is still running
                if (!threadIsAlive(.jump_thread))
                {
                    if (.controls.Jump.Press())
                    {
                        f.Jump(.controls.Jump);
                    }
                }
            }

            local u = .controls.Up.Hold();
            local d = .controls.Down.Hold();
            local l = .controls.Left.Hold();
            local r = .controls.Right.Hold();

            if (f.anim.facing == FACING.LEFT)
            {
                local temp = l;
                l = r;
                r = temp;
            }

            local move_mask = 0x0;

            if (u) { move_mask |= ComboActions.Up; }
            if (d) { move_mask |= ComboActions.Down; }
            if (l) { move_mask |= ComboActions.Forward; }
            if (r) { move_mask |= ComboActions.Backward; }

            g_dump.move_mask = move_mask;

            g_dump.current = f.ground_combo.current;

            // TODO: jump version
            if (.controls.Punch.Press())
            {
                .QueueComboAction(f.ground_combo, ComboActions.Punch | move_mask, .controls.Punch);
            }
            else if (.controls.Kick.Press())
            {
                .QueueComboAction(f.ground_combo, ComboActions.Kick | move_mask, .controls.Kick);
            }
            else if (.controls.Throw.Press())
            {
                .QueueComboAction(f.ground_combo, ComboActions.Throw | move_mask, .controls.Throw);
            }
            //else if (.controls.Block.Press())
            //{
                //.QueueComboAction(f.ground_combo, ComboActions.Block | move_mask, .controls.Block);
            //}

            if (!threadIsAlive(f.action_thread))
            {
                .ProcessComboActions();

                local combo_name = f.ground_combo.GetCombo();
                if (?combo_name)
                {
                    local combo_data = PlayerGroundAttacks[combo_name];

                    f.Combo(combo_data);

                    if (combo_data.finish)
                    {
                        f.ground_combo.Reset();
                    }
                }
            }

            yield();
        }
	};

    Controller:thread(Controller.Update);

	return Controller;
};

global MakePlayer = function(world, coord)
{
	local Player = MakeFighter(world, coord, "Player");

    Player.type = "Player";
	Player.mass = 1.2f;

    // TODO: move to config
	Player.air_max_speed = v3(6.0f, 4.0f, 8.0f);
	Player.ground_max_speed = v3(6.0f, 4.0f, 8.0f);
	Player.air_friction = v3(0.97f, 1.0f, 0.9f);
	Player.ground_friction = v3(0.7f, 0.7f, 0.9f);

    Player.ground_combo = MakeComboSystem(PlayerGroundComboChains, PlayerGroundAttacks);
    Player.air_combo = MakeComboSystem(PlayerGroundComboChains, PlayerGroundAttacks);

	Player.max_health = PlayerDefaults.MaxHealth;
	Player.health = Player.max_health;

    Player.FighterRelease = Player.Release;
    Player.Release = function()
    {
        //threadKill(.
        .FighterRelease();
    };

	Player.BaseOnPreUpdate = Player.OnPreUpdate;
	Player.OnPreUpdate = function()
	{
        .BaseOnPreUpdate();

        // TODO: get stage axis from .world.stage
		g_game.state.cam.SetTargetPos( v2(.pos) );
	};

	return Player;
};
