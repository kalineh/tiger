
global PlayerDefaults =
{
	MaxHealth = 40.0f,
	MaxEnergy = 20.0f,
	HealthRegen = 0.0f,
	EnergyRegen = 0.0f,
};

global MakeInput = function(f, a)
{
    local input = table();

    assert(?f);
    //assert(?a);

    input.fun = f;
    input.arg = a;

    // TODO: better name
    input.Check = function()
    {
        return .fun(.arg);
    };

	return input;
};

global PlayerControlsKeyboard =
{
	MoveFunction = MakeInput(function() {
		local result = v2(0.0f, 0.0f);
		if (Input.IsKeyDown("UP")) { result += v2(0.0f, +1.0f); }
		if (Input.IsKeyDown("DOWN")) { result += v2(0.0f, -1.0f); }
		if (Input.IsKeyDown("LEFT")) { result += v2(-1.0f, 0.0f); }
		if (Input.IsKeyDown("RIGHT")) { result += v2(+1.0f, 0.0f); }
		return result;
	}, null),

	Jump = MakeInput(Input.IsKeyDown, "X"),
	AttackPunch = MakeInput(Input.IsKeyDown, "C"),
	AttackKick = MakeInput(Input.IsKeyDown, "Z"),
	Slide = MakeInput(Input.IsKeyDown, "V"),
};

global ComboActions =
{
    Punch = 0,
    Kick = 1,
    Block = 2,
    Up = 3,
    Down = 4,
    Forward = 5,
    Backward = 6,
}; 

global PlayerGroundCombos =
{
    PunchL =
    {
        sequence = { 0 },
        anim = "punchl",
        damage = 1.0f,
        finish = false,
        stuns = false,
    },

    PunchR =
    {
        sequence = { 0,0 },
        anim = "punchr",
        damage = 1.0f,
        finish = false,
        stuns = false,
    },

    Kick =
    {
        sequence = { 1 },
        anim = "kick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },

    Knee =
    {
        sequence = { 0,0,5,1 },
        anim = "knee",
        damage = 1.0f,
        finish = true,
        stuns = true,
    },

    SpinKick =
    {
        sequence = { 0,0,0,1 },
        anim = "spinkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },

    SweepKick =
    {
        sequence = { 0,0,4,1 },
        anim = "sweepkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },
};

global PlayerAirCombos =
{
    JumpKick =
    {
        sequence = { 1 },
        anim = "jumpkick",
        damage = 2.0f,
        finish = true,
        stuns = false,
    },
};

global MakeComboSystem = function(data)
{
    assert(?data);

    local combo = table();

    combo.data = data;
    combo.sequence = table();
    combo.wait_thread = -1;
    combo.reset_thread = -1;
    combo.used_current_combo = false;

    combo.TryAddInput = function(action, input)
    {
        assert(?action);
        assert(?input);

        if (threadIsAlive(.wait_thread))
        {
            return;
        }

        .sequence[tableCount(.sequence)] = action;

        .WaitInput(input);
        .StartResetCountdown();

        .used_current_combo = false;
    };

    combo.Reset = function()
    {
        tableClear(.sequence);
        threadKill(.wait_thread);
    };

    combo.StartResetCountdown = function()
    {
        threadKill(.reset_thread);

        local reset_function = function()
        {
            sleep(0.5f);
            tableClear(.sequence);
        };

        .reset_thread = this:thread(reset_function);
    };

    combo.WaitInput = function(input)
    {
        if (threadIsAlive(.wait_thread))
        {
            return;
        }

        local wait_function = function(input)
        {
            while (input.Check())
            {
                yield();
            }
        };

        .wait_thread = this:thread(wait_function, input);
    };

    combo.GetCombo = function()
    {
        if (.used_current_combo)
        {
           return null;
        }

        foreach (name and data in .data)
        {
            if (tableCount(.sequence) < tableCount(data.sequence))
            {
                continue;
            }

            for (i = 0; i < tableCount(data.sequence); i += 1)
            {
                local current = .sequence[i];
                local desired = data.sequence[i];

                if (current != desired)
                {
                    break;    
                }

                if (i == tableCount(data.sequence) - 1)
                {
                    .used_current_combo = true;
                    return name;
                }
            }
        }

        return null;
    };

    return combo;
};

global MakePlayer = function(world, coord)
{
	local Player = MakeEntity(world, coord);

	Player.mass = 2.0f;
	Player.air_max_speed = v3(6.0f, 4.0f, 8.0f);
	Player.ground_max_speed = v3(6.0f, 4.0f, 8.0f);
	Player.air_friction = v3(1.0f, 1.0f, 0.9f);
	Player.ground_friction = v3(0.5f, 0.5f, 0.9f);

	Player.controls = PlayerControlsKeyboard;
	Player.type = EntityType.Player;
	Player.color = Gfx.WHITE;
	Player.max_health = PlayerDefaults.MaxHealth;
	Player.max_energy = PlayerDefaults.MaxEnergy;
	Player.health_regen = PlayerDefaults.HealthRegen;
	Player.energy_regen = PlayerDefaults.EnergyRegen;
	Player.health = Player.max_health;
	Player.energy = Player.max_energy;
	Player.shadow = MakeSpriteAnimation(g_game.animBank, "playerShadow");
	Player.anim = MakeSpriteAnimation(g_game.animBank, "player");
	Player.move_input = v2();
    Player.air_move_speed = v2(1.0f, 0.5f);
    Player.ground_move_speed = v2(3.0f, 2.0f);

    Player.attack_thread = -1;
    Player.block_thread = -1;
    Player.jump_thread = -1;
    Player.jump_finish_thread = -1;

    Player.ground_combo = MakeComboSystem(PlayerGroundCombos);
    Player.air_combo = MakeComboSystem(PlayerAirCombos);

	Player.OnTickTurn = function()
	{
		.health = min(.max_health, .health + .health_regen);
		.energy = min(.max_energy, .energy + .energy_regen);
	};

	Player.BaseDraw = Player.Draw;
	Player.Draw = function()
	{
        .BaseDraw();
	};

	Player.OnTakeDamage = function(damage)
	{
		g_game.soundBanks["game"].Play("playerTakeDamage");
		g_game.state.EmitParticlesAt("playerTakeDamage", .GetCenterWorld(), 16);
		.Shake(3.0f, 0.2f);
	};

	Player.IsInput = function(control)
	{
		local f = control[0];
		local a = control[1];
		local active = f(a);
		return active;
	};

	Player.OnUpdate = function()
	{
		g_game.state.cam.SetTargetPos( v2(.pos) );

        if (!threadIsAlive(.attack_thread))
        {
            local move = .controls.MoveFunction.Check();
            local move_speed = .ground_move_speed;

            if (.IsAirborne())
            {
                move_speed = .air_move_speed;
            }

            move *= move_speed;

            .accel += v3(move);
        }

        if (.controls.Jump.Check())
        {
            .TryJump();
        }

        local s = "";
        foreach ( k and v in .ground_combo.sequence )
        {
            s += v + ",";
        }
        print(s);

        if (.IsAirborne())
        {
        }
        else
        {
            if (.controls.AttackPunch.Check())
            {
                .ground_combo.TryAddInput(ComboActions.Punch, .controls.AttackPunch);
            }

            if (.controls.AttackKick.Check())
            {
                .ground_combo.TryAddInput(ComboActions.Kick, .controls.AttackKick);
            }

            local combo_name = .ground_combo.GetCombo();
            if (?combo_name)
            {
                local combo_data = PlayerGroundCombos[combo_name];
                assert(?combo_data);

                .TryAttack(combo_data);

                if (combo_data.finish)
                {
                    .ground_combo.Reset();
                }

                .ground_combo.used_current_combo = true;
            }
        }

        if (!threadIsAlive(.attack_thread) && !threadIsAlive(.jump_thread) && !.IsAirborne())
        {
            local len = safe_length(.vel + .accel);

            if (len <= 0.01f )
            {
                .anim.ChangeToNoReset("idle");
            }
            else
            {
                .anim.ChangeToNoReset("move");
                .anim.speed = abs(.vel.x) + abs(.vel.y);
            }
        }
        else
        {
            .anim.speed = 1.0f;
        }

        if (!threadIsAlive(.attack_thread))
        {
            if (.accel.x < 0.0f) { .anim.facing = FACING.RIGHT; }
            if (.accel.x > 0.0f) { .anim.facing = FACING.LEFT; }
        }

	};

    Player.TryJump = function()
    {
        if ( threadIsAlive(.jump_thread) )
        {
            return;
        }

        if ( threadIsAlive(.jump_finish_thread) )
        {
            return;
        }

        // TODO: a few frames before unable to jump
        if ( .IsAirborne() )
        {
            return;
        }

        local jump_function = function()
        {
            .anim.ChangeTo("jump");

            local jump_min_frames = 10;
            local jump_frames = 22;
            local jump_start = 5.0f;
            local jump_force = 5.0f;
            local jump_falloff = 0.1f;

            .vel = v3(.vel.x, .vel.y, jump_start);

            for (i = 0; i < jump_frames; i += 1)
            {
                if (i >= jump_min_frames)
                {
                    if (.controls.Jump.Check() == false)
                    {
                        break;
                    }
                }

                .accel += v3(0.0f, 0.0f, jump_force);

                jump_force = max( 0.0f, jump_force - jump_falloff );

                yield();
            }

            local jump_finish_function = function()
            {
                while (.controls.Jump.Check() == true)
                {
                    yield();
                }
            };

            .jump_finish_thread = this:thread(jump_finish_function);

            while (.IsAirborne())
            {
                yield();
            }
        };

        .jump_thread = this:thread(jump_function);
    };

    Player.CancelAttack = function()
    {
        // reset anim
        // kill thread
        assert(false);
    };

    Player.TryAttack = function(combo_data)
    {
        if (threadIsAlive(.attack_thread))
        {
            return;
        }

        local attack_function = function(combo_data)
        {
            assert(?combo_data);

            .anim.ChangeTo(combo_data.anim);

            // enable punch collision

            while (.anim.IsFinished() == false)
            {
                yield();
            }

            // disable punch collision
        };

        .attack_thread = this:thread(attack_function, combo_data);
    };
    
    Player.TryJumpAttack = function(attack_type, input)
    {
        assert(.IsAirborne());

        if (threadIsAlive(.attack_thread))
        {
            return;
        }

        local attack_function = function(attack_type, input)
        {
            local data = .attack_data[attack_type];

            assert(?data);

            .anim.ChangeTo(data.anim);

            // enable punch collision

            while (.anim.IsFinished() == false)
            {
                yield();
            }

            // disable punch collision

            //.combo_sequence[] = attack_type;

            // wait for combos
            // maybe spawn thread and sleep till combo reset
            // drop out of attack to allow another attack
        };

        .attack_thread = this:thread(attack_function, attack_type, input);
    };

    Player.RestartComboThread = function()
    {
        threadKill( .combo_thread );

        local combo_function = function()
        {
            sleep(0.5f);
            tableClear( .combo_sequence );
        };
    };
    
	Player.OnDie = function()
	{
		// zoom in death
		Tween.To(g_game.state.cam,  1.0f, {zoom=1.5});

		g_game.state.OnGameOver();

		// TEMPORARY: just make enemies walk around for funsies
		local postdie = function()
		{
			while (true)
			{
				.world.ReadyToTickTurn();
				sleep(0.5f);
			}
		};

		this:thread(postdie);
	};

	return Player;
};
