
global PlayerDefaults =
{
	MaxHealth = 40.0f,
	MaxFuel = 200.0f,
	MaxEnergy = 20.0f,
	FuelConsume = 1.0f,
	FuelRegen = 0.0f,
	HealthRegen = 0.0f,
	EnergyRegen = 0.0f,
};

global MakePlayer = function(world, coord)
{
	local Player = MakeEntity(world, coord);

	Player.type = EntityType.Player;
	Player.color = Gfx.WHITE;
	Player.pending_move = v2(0.0f);
	Player.max_health = PlayerDefaults.MaxHealth;
	Player.max_energy = PlayerDefaults.MaxEnergy;
	Player.health_regen = PlayerDefaults.HealthRegen;
	Player.energy_regen = PlayerDefaults.EnergyRegen;
	Player.health = Player.max_health;
	Player.energy = Player.max_energy;
	Player.anim = MakeSpriteAnimation(g_game.animBank, "player");

	Player.OnTickTurn = function()
	{
		.health = min(.max_health, .health + .health_regen);
		.energy = min(.max_energy, .energy + .energy_regen);
	};

	Player.Draw = function()
	{
		local p = .pos * .world.tilesize;	

		Gfx.Color(.color, .alpha);
		.anim.Draw(p+.drawOffset);

		// low health, draw particles
		if ( .health <= 10 )
		{
			if ( randint(0,5)==0 )
			{
				g_game.state.EmitParticlesAt("playerTakeDamage", .GetCenterWorld(), 1);
			}

			// fire
			Gfx.Color(Gfx.WHITE, 0.6f);
			.animFire.Draw(p+.drawOffset + v2(-32.0f, -12.0f ) );
		}
	};

	Player.OnPostTickTurn = function()
	{
		local data = .world.GetTileDataSafe(.coord);
		local burning = TileDataGetBits.Burning(data);

		if (burning > 0)
		{
			.TakeDamage(burning * 0.5f);
		}
	};

	Player.OnTakeDamage = function(damage)
	{
		g_game.soundBanks["game"].Play("playerTakeDamage");
		g_game.state.EmitParticlesAt("playerTakeDamage", .GetCenterWorld(), 16);
		.Shake(3.0f, 0.2f);
	};

	Player.OnUpdate = function()
	{
		g_game.state.cam.SetTargetPos((.coord+v2(0.5f)) * .world.tilesize);
		._UpdateInput();
	};

	Player.GiveAbility = function(ability)
	{
		// TODO: probably player should hold abilities internally?

		// TODO: if ability already exists, give +1 powerup

		local cards = g_game.state.gui.cards;

		foreach (card in cards)
		{
			if (?card.ability && card.ability.title == ability.title)
			{
				card.ability.AddLevel();
				return;
			}
		}

		for (i = 0; i < 9; i += 1)
		{
			if (!?cards[i].ability)
			{
				cards[i].ability = ability;
				return;
			}
		}
	};

	Player._InitInputs = function()
	{
		.inputsMovement = 
		{
			UP = { fun = function() { return .InputMove(+0.0f, +1.0f); }, arg = null },
			DOWN = { fun = function() { return .InputMove(+0.0f, -1.0f); }, arg = null },
			LEFT = { fun = function() { return .InputMove(-1.0f, +0.0f); }, arg = null },
			RIGHT = { fun = function() { return .InputMove(+1.0f, +0.0f); }, arg = null },
			KP1 = { fun = function() { return .InputMove(-1.0f, -1.0f); }, arg = null },
			KP2 = { fun = function() { return .InputMove(+0.0f, -1.0f); }, arg = null },
			KP3 = { fun = function() { return .InputMove(+1.0f, -1.0f); }, arg = null },
			KP4 = { fun = function() { return .InputMove(-1.0f, +0.0f); }, arg = null },
			KP5 = { fun = function() { return .InputWait(); }, arg = null },
			KP6 = { fun = function() { return .InputMove(+1.0f, +0.0f); }, arg = null },
			KP7 = { fun = function() { return .InputMove(-1.0f, +1.0f); }, arg = null },
			KP8 = { fun = function() { return .InputMove(+0.0f, +1.0f); }, arg = null },
			KP9 = { fun = function() { return .InputMove(+1.0f, +1.0f); }, arg = null },
			SPACE = { fun = function() { return .InputWait(); }, arg = null, },
			E = { fun = function() { return .InputEscape(); }, arg = null, },
		};
	};

	Player._UpdateInput = function()
	{
		foreach (k and v in .inputs)
		{
			if (Input.DidKeyJustGoDown(k))
			{
				local fun = v.fun;
				local arg = v.arg;
				local ready = this:fun(arg);

				// must return a true/false, null probably error
				assert(?ready);

				if (ready)
				{
					.world.ReadyToTickTurn();
				}
				break;
			}
		}
	};

	Player.InputMove = function(x, y)
	{		
		.pending_move = v2(x, y);
		return true;
	};

	Player.InputWait = function()
	{
		.pending_move = v2(0.0f);
		return true;
	};

	Player.GetDirectionalInput = function(allow_diagonal, fallback)
	{
		if (Input.DidKeyJustGoDown("UP")) { return v2(0.0f, +1.0f); }
		if (Input.DidKeyJustGoDown("DOWN")) { return v2(0.0f, -1.0f); }
		if (Input.DidKeyJustGoDown("LEFT")) { return v2(-1.0f, 0.0f); }
		if (Input.DidKeyJustGoDown("RIGHT")) { return v2(+1.0f, 0.0f); }

		if (Input.DidKeyJustGoDown("KP8")) { return v2(0.0f, +1.0f); }
		if (Input.DidKeyJustGoDown("KP2")) { return v2(0.0f, -1.0f); }
		if (Input.DidKeyJustGoDown("KP4")) { return v2(-1.0f, 0.0f); }
		if (Input.DidKeyJustGoDown("KP6")) { return v2(+1.0f, 0.0f); }

		if (allow_diagonal)
		{
			if (Input.DidKeyJustGoDown("KP7")) { return v2(-1.0f, +1.0f); }
			if (Input.DidKeyJustGoDown("KP9")) { return v2(+1.0f, +1.0f); }
			if (Input.DidKeyJustGoDown("KP3")) { return v2(+1.0f, -1.0f); }
			if (Input.DidKeyJustGoDown("KP1")) { return v2(-1.0f, -1.0f); }
		}

		if (!?fallback)
		{
			fallback = v2(0.0f);
		}

		return fallback;
	};

	Player.OnDie = function()
	{
		// zoom in death
		Tween.To(g_game.state.cam,  1.0f, {zoom=1.5});

		g_game.state.OnGameOver();

		// TEMPORARY: just make enemies walk around for funsies
		local postdie = function()
		{
			while (true)
			{
				.world.ReadyToTickTurn();
				sleep(0.5f);
			}
		};

		this:thread(postdie);
	};

	Player._InitInputs();

	return Player;
};
