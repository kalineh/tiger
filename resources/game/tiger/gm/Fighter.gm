
global FighterConfig =
{
    Player = 
    {
        MaxHealth = 10.0f,
        MaxEnergy = 10.0f,
        Animations = "player",
    },

    Thug = 
    {
        MaxHealth = 50.0f,
        MaxEnergy = 0.0f,
        Animations = "player",
    },
};

global MakeFighter = function(world, coord, config_name)
{
	local Fighter = MakeEntity(world, coord);
    local config = FighterConfig[config_name];

    assert(?config_name);
    assert(?config);

	Fighter.type = "Enemy";
	Fighter.controls = null;
	Fighter.color = Gfx.WHITE;
	Fighter.max_health = config.MaxHealth;
	Fighter.max_energy = config.MaxEnergy;
	Fighter.health = Fighter.max_health;
	Fighter.energy = Fighter.max_energy;
	Fighter.stun = 0;
	Fighter.shadow = MakeSpriteAnimation(g_game.animBank, config.Animations + "_shadow");
	Fighter.anim = MakeSpriteAnimation(g_game.animBank, config.Animations);
	Fighter.move_input = v2();
    Fighter.air_move_speed = v2(1.0f, 0.5f);
    Fighter.ground_move_speed = v2(1.5f, 0.75f);
    Fighter.frames_ground = 0;
    Fighter.frames_air = 0;
    Fighter.action_thread = -1;
    Fighter.jump_thread = -1;
    Fighter.ground_combo = MakeComboSystem(PlayerGroundComboChains, PlayerGroundAttacks);
    Fighter.air_combo = MakeComboSystem(PlayerGroundComboChains, PlayerGroundAttacks);
    Fighter.collision_body = MakeCollision(Fighter, CollisionType.Circle, 32.0f);
    Fighter.collision_weapon = MakeCollision(Fighter, CollisionType.Circle, 16.0f);

    Fighter.collision_body.SetEnabled(false);
    Fighter.collision_weapon.SetEnabled(false);

    world.collision_manager.Add(Fighter.collision_body);
    world.collision_manager.Add(Fighter.collision_weapon);

    Fighter.EntityRelease = Fighter.Release;
    Fighter.Release = function()
    {
        .world.collision_manager.Remove(.collision_body);
        .world.collision_manager.Remove(.collision_weapon);
        threadKill(.action_thread);
        threadKill(.jump_thread);
        .EntityRelease();
    };

	Fighter.OnPreUpdate = function()
	{
        local airborne = .IsAirborne();

        if (airborne)
        {
            .frames_ground = 0;
            .frames_air += 1;
        }
        else
        {
            .frames_ground += 1;
            .frames_air = 0;
        }

        if (!threadIsAlive(.action_thread))
        {
            local move = .move_input;
            local move_speed = .ground_move_speed;

            if (.IsAirborne())
            {
                move_speed = .air_move_speed;
            }

            move *= move_speed;

            .accel += v3(move);
        }

        .anim.speed = 1.0f;

        if (.stun > 0)
        {
            .anim.ChangeToNoReset("stun");
            .stun -= 1;
            return;
        }

        if (!threadIsAlive(.action_thread))
        {
            if (.frames_ground >= 1)
            {
                if (.move_input.x < 0.0f) { .anim.facing = FACING.RIGHT; }
                if (.move_input.x > 0.0f) { .anim.facing = FACING.LEFT; }

                local len = safe_length(.vel + .accel);

                if (len <= 0.01f )
                {
                    .anim.ChangeToNoReset("idle");
                }
                else
                {
                    if (.move_input.x < 0.0f)
                    {
                        if (.vel.x > 0.0f)
                        {
                            .anim.ChangeToNoReset("stop");
                        }
                        else
                        {
                            .anim.ChangeToNoReset("move");
                        }
                    }
                    if (.move_input.x > 0.0f)
                    {
                        if (.vel.x < 0.0f)
                        {
                            .anim.ChangeToNoReset("stop");
                        }
                        else
                        {
                            .anim.ChangeToNoReset("move");
                        }
                    }

                    if (.anim.currAnimName == "move")
                    {
                        .anim.speed = abs(.vel.x) + abs(.vel.y);
                    }
                }
            }
            else // airborne
            {
                if (.vel.z < 0.0f)
                {
                    .anim.ChangeToNoReset("fall");
                }
                else if (.vel.z > 0.0f)
                {
                    .anim.ChangeToNoReset("jump");
                }
            }
        }
	};

    Fighter.OnPostUpdate = function()
    {
        local center = .GetAnimCenter();
        local dir = .GetFacingDir();

        // TODO: facing is backwards?
        dir *= -1.0f;

        .collision_body.SetEnabled(true);

        .collision_body.SetPosition(center);
        .collision_weapon.SetPosition(center + dir * 48.0f);
    };

    Fighter.Jump = function(input)
    {
        assert(!threadIsAlive(.jump_thread));
        assert(?input);

        local jump_function = function(input)
        {
            assert(?input);

            local jump_min_frames = 10;
            local jump_frames = 34;
            local jump_start = 5.0f;
            local jump_force = 5.0f;
            local jump_falloff = 0.12f;

            .vel = v3(.vel.x, .vel.y, jump_start);

            for (i = 0; i < jump_frames; i += 1)
            {
                if (i >= jump_min_frames)
                {
                    if (!input.Hold())
                    {
                        break;
                    }
                }

                .accel += v3(0.0f, 0.0f, jump_force);

                jump_force = max(0.0f, jump_force - jump_falloff);

                yield();
            }

            while (.frames_air > 0)
            {
                yield();
            }
        };

        .jump_thread = this:thread(jump_function, input);
    };

    Fighter.Combo = function(combo_data)
    {
        assert(!threadIsAlive(.action_thread));

        local combo_function = function(combo_data)
        {
            assert(?combo_data);

            .anim.ChangeTo(combo_data.anim);

            // TODO: some better way of doing this?
            .collision_weapon.damage = combo_data.damage;
            .collision_weapon.stun = combo_data.stun;
            .collision_weapon.push = combo_data.push;

            while (.anim.IsFinished() == false)
            {
                local hit_tag = .anim.HasTag("hit");

                .collision_weapon.SetEnabled(hit_tag);

                yield();
            }

            .collision_weapon.damage = null;
            .collision_weapon.stun = null;
            .collision_weapon.push = null;

            .collision_weapon.SetEnabled(false);
        };

        .action_thread = this:thread(combo_function, combo_data);
    };

    Fighter.Stun = function(stun)
    {
        .stun += stun;
    };

    Fighter.OnCollide = function(lhs, rhs)
    {
        if (lhs == .collision_body)
        {
            if (rhs == rhs.owner.collision_body || rhs == rhs.owner.collision_weapon)
            {
                local damage = rhs.damage;
                local stun = rhs.stun;
                local push = rhs.push;

                // TODO: better handling for body collision
                if (!?damage) { damage = 1.0f; }
                if (!?stun) { stun = 0; }
                if (!?push) { push = 1.0f; }

                .TakeDamage(damage);
                .Stun(stun);

                local ofs = .pos - rhs.owner.pos;

                .vel = v3(0.0f, 0.0f, 0.0f);
                .accel = ofs * push;
            }
        }

        return false;
    };

	return Fighter;
};
