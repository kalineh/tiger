
global EntityType =
{
	MaskAll = 0xFF,
	MaskHostile = 0x02, 
	None = 0x00,
	Player = 0x01,
	Enemy = 0x02,
	Pickup = 0x04,
};

global MakeEntity = function(world, pos)
{
	assert(?world);
	assert(?pos);
	assert(?pos.x);
	assert(?pos.y);

	local Entity = table();

	Entity.type = EntityType.None;
	Entity.pos = pos;
	Entity.height = 0.0f;
	Entity.height_vel = 0.0f;
	Entity.height_accel = 0.0f;
	Entity.height_friction = 0.85f;
	Entity.vel = v2(0.0f);
	Entity.accel = v2(0.0f);
	Entity.friction = v2(0.05f);
	Entity.coord = coord;
	Entity.size = v2(1.0f);
	Entity.world = world;
	Entity.color = Gfx.WHITE;
	Entity.max_health = 1.0f;
	Entity.health = 1.0f;
	Entity.post_tick_notify = MakeNotify(Entity, "PostTickNotify");
	Entity.take_damage_filters = table();
	Entity.draw_offset = v2(0.0f);
	Entity.alpha = 1.0f;

	Entity.IsInsideCam = function()
	{
        // TODO: size should be texture size?
        // TODO: fix calculations for non-tile world style (zoom, etc)
        return true;
        return g_game.state.cam.CanSeeBox( .pos, .size );
	};

    Entity.GetDrawPosition = function()
    {
        local p = .pos;
        local o = .draw_offset;
        local h = v2(0.0f, .height);

        // TODO: height maybe needs scaling?

        return p + o + h;
    };

	Entity.Draw = function()
	{
        local draw_position = .GetDrawPosition();

		if ( ?.anim )
		{
			// render only if in camera
			if ( .IsInsideCam() )
			{
				Gfx.Color(.color, .alpha);
				.anim.Draw(draw_position);
			}
		}
		else
		{
			// TODO: camera visible check
			//if (g_game.state.cam.IsVisible(.coord * t, e) == false)
			//{
				//return;
			//}

            local size = v2(32.0f);

			Gfx.BeginDefaultShader();
			Gfx.Color(.color);
			Gfx.DrawRectRounded(draw_position, size, 10.0f);

			if ( this == .world.GetPlayer() )
			{
				Gfx.Color(Gfx.GREEN);
			}
			else
			{
				Gfx.Color(Gfx.RED*0.5f);
			}

			Gfx.SetLineWidth(3.0f);
			
			Gfx.DrawRectRoundedWire(p, s, 10.0f);
			Gfx.SetLineWidth(1.0f);

			// face
			Gfx.Color(.color * 0.5f);
			Gfx.DrawRect(draw_position + size * v2(0.2f, 0.6f), e * 0.2f);
			Gfx.DrawRect(draw_position + size * v2(0.6f, 0.6f), e * 0.2f);
			Gfx.DrawRect(draw_position + size * v2(0.2f, 0.2f), e * v2(0.6f, 0.1f));

			Gfx.EndDefaultShader();
		}
	};

	Entity.IsDead = function()
	{
		return .health <= 0.0f;
	};

	Entity.OnTakeDamage = function()
	{
	};

	Entity.Shake = function( range, time )
	{
		fork id
		{
			while(true)
			{
				.draw_offset = v2(randfloat(-range,range), randfloat(-range,range));
				yield();
			}
		}

		fork
		{
			sleep(time);
			threadKill(id);
		}
	};

	Entity.TakeDamage = function(damage)
	{
		foreach (key and filter in .take_damage_filters)
		{
			damage = key:filter(damage);
		}

		if ( damage > 0.0f )
		{
			.OnTakeDamage(damage);
		}

		// TODO: damage type different particles
		// TODO: damage resist/reflect different particles

		// flash red
		.color = Gfx.RED;
		Tween.To( this, 0.3f, {color=Gfx.WHITE} );
		DrawNotifyText( "-"+damage.Int(), .GetCenterWorld() + v2(0.0f,0.5f*.world.tilesize.x), Gfx.RED);

		//g_game.state.EmitParticlesAt("entityTakeDamage", .GetCenterWorld(), 5*damage.Int());

		.health -= damage;
		if (.health <= 0.0f)
		{
			.Die();
		}
	};

	Entity.TickTurn = function()
	{
	};

	Entity.Update = function()
	{
		while( true )
		{		
			.OnUpdate();
            .Physics();
			yield();
		}
	};

	Entity.OnUpdate = function()
	{
	};

	Entity.Physics = function()
	{
        .vel += .accel;
        .pos += .vel;
        .vel *= .friction;
        .accel = v2(0.0f);

        local gravity = -0.05f;
        local gravity = -0.0f;

        // TODO: v3 all of this probably
        .height_accel += gravity;
        .height_vel += .height_accel;
        .height += .height_vel;
        .height = max(.height_vel, 0.0f);
        .height_vel *= .height_friction;
        .height_accel = 0.0f;

        if (.height < 0.01f)
        {
            .height = 0.0f;
        }
	};

	Entity.Die = function()
	{
		.OnDie();
		.world.AddDeathRow(this);
	};

	Entity.OnDie = function()
	{
		// animations
		// effects
		// sounds
	};

	Entity.Init = function()
	{	
		.threadId = this:thread(.Update);
	};

	Entity.Release = function()
	{
		if ( ?.anim ) 
		{
			.anim.Release();
			.anim = null;
		}

		threadKill(.threadId);
	};
	
	Entity.Init();
	return Entity;
};
