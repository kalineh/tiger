
global EntityType =
{
	MaskAll = 0xFF,
	MaskHostile = 0x02, 
	None = 0x00,
	Player = 0x01,
	Enemy = 0x02,
	Pickup = 0x04,
};

global MakeEntity = function(world, pos)
{
	assert(?world);
	assert(?pos);
	assert(?pos.x);
	assert(?pos.y);
	assert(?pos.z);

	local Entity = table();

	Entity.type = EntityType.None;
	Entity.pos = pos;
	Entity.vel = v3(0.0f);
	Entity.accel = v3(0.0f);
	Entity.friction = v3(0.5f, 0.5f, 0.9f);
    Entity.mass = 1.0f;
	Entity.coord = coord;
	Entity.size = v2(1.0f);
	Entity.world = world;
	Entity.color = Gfx.WHITE;
	Entity.max_health = 1.0f;
	Entity.health = 1.0f;
	Entity.post_tick_notify = MakeNotify(Entity, "PostTickNotify");
	Entity.take_damage_filters = table();
	Entity.draw_offset = v2(0.0f);
	Entity.alpha = 1.0f;

	Entity.IsInsideCam = function()
	{
        // TODO: size should be texture size?
        // TODO: fix calculations for non-tile world style (zoom, etc)
        return true;
        return g_game.state.cam.CanSeeBox( .pos, .size );
	};

    Entity.GetDrawPosition = function()
    {
        local p = v2(.pos);
        local o = .draw_offset;
        local h = .pos.z;

        // TODO: height maybe needs scaling?

        return p + o + v2(0.0f, h);
    };

	Entity.Draw = function()
	{
        local draw_position = .GetDrawPosition();

		if ( ?.anim )
		{
			// render only if in camera
			if ( .IsInsideCam() )
			{
				Gfx.Color(.color, .alpha);
				.anim.Draw(draw_position);
			}
		}
		else
		{
			// TODO: camera visible check
			//if (g_game.state.cam.IsVisible(.coord * t, e) == false)
			//{
				//return;
			//}

            local size = v2(32.0f);

			Gfx.BeginDefaultShader();
			Gfx.Color(.color);
			Gfx.DrawRectRounded(draw_position, size, 10.0f);

			if ( this == .world.GetPlayer() )
			{
				Gfx.Color(Gfx.GREEN);
			}
			else
			{
				Gfx.Color(Gfx.RED*0.5f);
			}

			Gfx.SetLineWidth(3.0f);
			
			Gfx.DrawRectRoundedWire(p, s, 10.0f);
			Gfx.SetLineWidth(1.0f);

			// face
			Gfx.Color(.color * 0.5f);
			Gfx.DrawRect(draw_position + size * v2(0.2f, 0.6f), e * 0.2f);
			Gfx.DrawRect(draw_position + size * v2(0.6f, 0.6f), e * 0.2f);
			Gfx.DrawRect(draw_position + size * v2(0.2f, 0.2f), e * v2(0.6f, 0.1f));

			Gfx.EndDefaultShader();
		}
	};

	Entity.IsDead = function()
	{
		return .health <= 0.0f;
	};

	Entity.OnTakeDamage = function()
	{
	};

	Entity.Shake = function( range, time )
	{
		fork id
		{
			while(true)
			{
				.draw_offset = v2(randfloat(-range,range), randfloat(-range,range));
				yield();
			}
		}

		fork
		{
			sleep(time);
			threadKill(id);
		}
	};

	Entity.TakeDamage = function(damage)
	{
		foreach (key and filter in .take_damage_filters)
		{
			damage = key:filter(damage);
		}

		if ( damage > 0.0f )
		{
			.OnTakeDamage(damage);
		}

		// TODO: damage type different particles
		// TODO: damage resist/reflect different particles

		// flash red
		.color = Gfx.RED;
		Tween.To( this, 0.3f, {color=Gfx.WHITE} );
		DrawNotifyText( "-"+damage.Int(), .GetCenterWorld() + v2(0.0f,0.5f*.world.tilesize.x), Gfx.RED);

		//g_game.state.EmitParticlesAt("entityTakeDamage", .GetCenterWorld(), 5*damage.Int());

		.health -= damage;
		if (.health <= 0.0f)
		{
			.Die();
		}
	};

    Entity.IsAirborne = function()
    {
        return .pos.z > 0.01f;
    };

	Entity.Update = function()
	{
		while( true )
		{		
			.OnUpdate();
            .Physics();
			yield();
		}
	};

	Entity.OnUpdate = function()
	{
	};

	Entity.Physics = function()
	{
        local gravity = v3(0.0f, 0.0f, -1.0f);

        .accel += gravity * .mass;
        .vel += .accel;
        .pos += .vel;
        .vel *= .friction;
        .accel = v3(0.0f);

        .pos = v3(.pos.x, .pos.y, max(0.0f, .pos.z));

        if (.IsAirborne() == false)
        {
            .vel *= v3(1.0f, 1.0f, 0.0f);
        }
	};

	Entity.Die = function()
	{
		.OnDie();
		.world.AddDeathRow(this);
	};

	Entity.OnDie = function()
	{
		// animations
		// effects
		// sounds
	};

	Entity.Init = function()
	{	
		.threadId = this:thread(.Update);
	};

	Entity.Release = function()
	{
		if ( ?.anim ) 
		{
			.anim.Release();
			.anim = null;
		}

		threadKill(.threadId);
	};
	
	Entity.Init();
	return Entity;
};
